我们来看这样一段代码：
#include <stdio.h>
#define cube(x)((x)*(x)*(x))
int main() {
	printf("%d\n",cube(5));
	return 0;
}
在gcc -save-temps code.c 后查看code.i文件，就会发现
int main() {
 printf("%d\n",((5)*(5)*(5)));
 return 0;
}

我们可以把宏当做函数来使用
甚至这样也是可以的
int main() {
 int i;
 scanf("%d",&i);
 printf("%d\n",((i)*(i)*(i)));
 return 0;
}


对于下的一段代码：
#define RADTODEG1(x) (x * 57.29578)
#define RADTODEG2(x) (x) * 57.29578
int main() {
	printf("%f\n",RADTODEG1(5+2));
	printf("%f\n",180/RADTODEG2(1));
	return 0;
}

他的code.i文件为：
int main() {



 printf("%f\n",(5+2 * 57.29578));
 printf("%f\n",180/(1) * 57.29578);
 return 0;
}

你会发现和我们的目的完全反了，所以以后在定义宏的时候，我们需要

*一一切都要括号
*整个值要括号
*参数出现的每个地方方都要括号
#define RADTODEG(x) ((x) * 57.29578)

宏定义末尾不能加分号，例如：
#define PRETTY_PRINT(msg) printf(msg);
if (n < 10)
PRETTY_PRINT("n is less than 10");
else
PRETTY_PRINT("n is at least 10");
上面的代码因为宏加了分号，使得if和后面的else没有了关系


• 在大大型程序的代码中使用用非非常普遍
• 可以非非常复杂,如“产生生”函数
•
在#和##这两个运算符的帮助下
• 存在中⻄西方方文文化差异
• 部分宏会被inline函数替代